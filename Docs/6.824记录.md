# Lab1

### 结构体定义

MapReduce只有两个部分：Master和Worker。其中Master负责任务的分配和Worker的调度，Worker负责具体任务的执行。这也就意味着worker是无状态的，且不同Worker之间是不可见的，只需要根据获得的任务类型进行相应的执行即可。

Master是MapReduce的大脑，因此内部需要维护一个状态机来确定当前所处的阶段（是Map过程还是Reduce过程）；需要有一个并发安全的任务分配工具，我这里使用的是一个channel；此外我还定义了一个并发安全的TaskQueue（实际上是一个map），用来记录已经开始的任务，用来防止Worker长时间占用某个Task而无法完成。

Task是任务的主体，这里只提一个比较重要的变量：任务的开始时间。任务的开始时间标志着Worker获取到当前Task的时间戳，实际上这更类似于Worker对与Master的保活心跳。因为从更高一点的角度来看，Worker正是通过不停的获取任务、在规定时间完成任务来向Master证明自己的健康程度。

### 执行流程

总的来说，尽管任务的分配是由Master进行的，但是Master所处的状态和下一步的操作实际上是Worker在推动的（因为Master自身并不会“做任务”）。每个Worker在启动以后，只会循环不停地做三件事情：获取任务->处理任务->通知Master任务已经完成。

**获取任务**：Master程序将会首先启动，并监听它暴露给Worker的接口。Master在启动时会初始化全部的Map任务，将其放在对应的channel中，以便后续分发。Worker在启动后，通过RPC方法向Master请求一个任务，若此时全部的任务已经分发完毕，Master会回复一个简要的消息并要求Worker等待若干时间后重试。

**处理任务**：Worker本身的工作就是完成任务，会根据从Master获得的任务类型来选择不同的执行策略：比如调用用户编写的map函数执行map任务。

**发送通知**：发送通知这个过程比我们想象的要更重要。首先，Worker需要告诉Master它到底完成了哪个任务，并将这个任务从TaskQueue中剔除。这某种程度相当于在向Master证明自己存活或者有能力完成任务，否则Master就会在一段时间以后将这个任务重新分配给别的Worker，导致任务的重复执行。同时，一个任务的执行也会**推动Master所处阶段的改变**，例如如果某个任务是Map阶段的最后一个任务，它的完成就标志着Master从Map阶段到Reduce阶段的转变
